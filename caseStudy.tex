\chapter{Case Study}
\section{Analysis of Multi-threaded Programs}
\label{ch:thread}
In a multi-threaded program, information flows among threads because of communication and synchronization among them. There are two types of semaphores counting and binary, for synchronization among threads. For now, our script handles binary semaphores only. 
\subsection{Handling Information flow due to WAIT and SIGNAL operations}
Traditional operations related to binary semaphore are WAIT and SIGNAL. SIGNAL operation changes the value of semaphore 0 to 1 and WAIT operation wait for an infinite time if the current value of the semaphore is 0 otherwise it changes value 1 to 0 and allows control flow forward. There are three operations related to the binary semaphore in python language wait(), set() and clear(). Traditional WAIT operation can be simulated using python wait() followed by clear() operation, SIGNAL is equivalent to set().\\~\\
\begin{minipage}[b]{0.45\linewidth}
	\centering
	\begin{lstlisting}[ numbers=left, mathescape,%
	caption={Example of wait() operation on binary semaphore.Info Flow: s$\rightarrow$x}, label=lst:wait]
	s = threading.Event()
	s.wait()
	x = 1
	
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.45\linewidth}
	\centering
	\begin{lstlisting}[ mathescape,%
	caption={Infinite while loop, Information Flow: x$\rightarrow$y }, label=lst:whilewait]
	y = 0
	while x:
	pass
	y = 1
	\end{lstlisting}
\end{minipage}\\
Listing \ref{lst:wait} and Listing \ref{lst:whilewait} show that control flow of wait()  is similar to infinite while loop so we treat wait() in a similar way. All statements which use global variables as a target of assignment and are preceded by wait() may transmit information to other threads. So information flows from semaphore $s_0$ to targets of assignment operations which follows $s_0$.wait() statement.\\
All semaphore operations simplified into normal operations.
\begin{itemize}
	\item s.set() treated as \textbf{s = s + 1}.
	\item s.clear() treated as \textbf{s = s - 1}.
	\item Listing \ref{lst:wait} and \ref{lst:whilewait} shows s.wait() equivalent to \textbf{while(s == 0) \{ skip \}}.
\end{itemize}
\subsubsection{Benchmarking of Certification Script using Denning's Example \cite{denning}}
\begin{lstlisting}[language=Python, caption=Python version of copy3 example in \cite{denning}. goal: information flow from x to y, label={lst:copy3} ]
#Procedure copy3
import thread
import time
import threading
s0 = threading.Event()
s1 = threading.Event()

def thread1():
global x
if x==0:
s0.set()
else:
s1.set()

def thread2():
global y
s0.wait()
s0.clear()
y=1
s1.set()

def thread3():
global y
s1.wait()
s1.clear()
y=0
s0.set()

thread.start_new_thread(thread1,())
thread.start_new_thread(thread2,())
thread.start_new_thread(thread3,())
\end{lstlisting}

To certify the multi-threaded program in Listing \ref{lst:copy3} correctly our script must track information flow from x to y (x $\rightarrow$ y) and must generate constraints accordingly.\\
Constraints generated by our script for program in Listing \ref{lst:copy3} are:
\begin{enumerate}
	\item \dud{x} $\oplus$ \dud{s0} $\leqslant$  \dud{s0}
	\item\dud{x} $\oplus$ \dud{s1} $\leqslant$  \dud{s1}
	\item\dud{s0} $\leqslant$ \dud{s0}
	\item\dud{s0} $\leqslant$ \dud{y}
	\item\dud{s1} $\oplus$ \dud{s0} $\leqslant$  \dud{s1}
	\item\dud{s1} $\leqslant$ \dud{s1}
	\item\dud{s1} $\leqslant$ \dud{y}
	\item\dud{s1} $\oplus$ \dud{s0} $\leqslant$  \dud{s0}
\end{enumerate}  
constraint 1 (\dud{x} $\oplus$ \dud{s0} $\leqslant$  \dud{s0}) and constraint 4 (\dud{s0} $\leqslant$ \dud{y}) \hspace{1cm} $\equiv$ \hspace{1cm} \dud{x} $\leqslant$ \dud{y}.\\
constraint 2 ( \dud{x} $\oplus$ \dud{s1}    $\leqslant$  \dud{s1}) and constraint 7 ( \dud{s1} $\leqslant$ \dud{y}) \hspace{1cm} $\equiv$ \hspace{1cm} 
\dud{x} $\leqslant$ \dud{y}.\\	
Hence script is able to generate correct constraints in multi-threaded program too.

