\BOOKMARK [0][-]{chapter.1}{Introduction}{}% 1
\BOOKMARK [1][-]{section.1.1}{Language Based Security}{chapter.1}% 2
\BOOKMARK [1][-]{section.1.2}{Noninterference}{chapter.1}% 3
\BOOKMARK [1][-]{section.1.3}{Security of a program}{chapter.1}% 4
\BOOKMARK [2][-]{subsection.1.3.1}{Motivation}{section.1.3}% 5
\BOOKMARK [2][-]{subsection.1.3.2}{Goals}{section.1.3}% 6
\BOOKMARK [0][-]{chapter.2}{Background}{}% 7
\BOOKMARK [1][-]{subsection.2.0.1}{Bell Lapadula security model lapadula}{chapter.2}% 8
\BOOKMARK [2][-]{subsection.2.0.2}{Biba Security Model biba}{subsection.2.0.1}% 9
\BOOKMARK [2][-]{subsection.2.0.3}{Denning's Lattice model denning}{subsection.2.0.1}% 10
\BOOKMARK [2][-]{subsection.2.0.4}{Reader Writer Flow Model rwfm}{subsection.2.0.1}% 11
\BOOKMARK [0][-]{chapter.3}{Secure Information Flow Analysis of Python Programs}{}% 12
\BOOKMARK [0][-]{chapter.4}{Approach to certify Python Programs}{}% 13
\BOOKMARK [1][-]{subsection.4.0.1}{ Category 1 constraint Generator : PC reset and fixed labels.}{chapter.4}% 14
\BOOKMARK [2][-]{subsection.4.0.2}{Working}{subsection.4.0.1}% 15
\BOOKMARK [1][-]{section.4.1}{Constraint Rules}{chapter.4}% 16
\BOOKMARK [2][-]{subsection.4.1.1}{Key Idea}{section.4.1}% 17
\BOOKMARK [1][-]{section.4.2}{Limitations}{chapter.4}% 18
\BOOKMARK [1][-]{section.4.3}{Category 2 constraints : PC monotonic and fixed labels.}{chapter.4}% 19
\BOOKMARK [2][-]{subsection.4.3.1}{Working}{section.4.3}% 20
\BOOKMARK [2][-]{subsection.4.3.2}{Key Idea}{section.4.3}% 21
\BOOKMARK [2][-]{subsection.4.3.3}{Limitations}{section.4.3}% 22
\BOOKMARK [1][-]{section.4.4}{Category 3 constraints : PC reset and dynamic labels.}{chapter.4}% 23
\BOOKMARK [2][-]{subsection.4.4.1}{Constraint Rules}{section.4.4}% 24
\BOOKMARK [2][-]{subsection.4.4.2}{Key Idea}{section.4.4}% 25
\BOOKMARK [2][-]{subsection.4.4.3}{Limitations}{section.4.4}% 26
\BOOKMARK [1][-]{section.4.5}{Category 4 constraints: PC monotonic and dynamic label.}{chapter.4}% 27
\BOOKMARK [2][-]{subsection.4.5.1}{Key Idea}{section.4.5}% 28
\BOOKMARK [2][-]{subsection.4.5.2}{Limitations}{section.4.5}% 29
\BOOKMARK [1][-]{section.4.6}{Comparison among all categories of constraints.}{chapter.4}% 30
\BOOKMARK [0][-]{chapter.5}{Implementation of Constraint Generator}{}% 31
\BOOKMARK [1][-]{subsection.5.0.1}{Contributions}{chapter.5}% 32
\BOOKMARK [2][-]{subsection.5.0.2}{Implementation Details}{subsection.5.0.1}% 33
\BOOKMARK [0][-]{chapter.6}{Case Study}{}% 34
\BOOKMARK [1][-]{section.6.1}{Analysis of Multi-threaded Programs}{chapter.6}% 35
\BOOKMARK [2][-]{subsection.6.1.1}{Handling Information flow due to WAIT and SIGNAL operations}{section.6.1}% 36
\BOOKMARK [0][-]{chapter.7}{Conclusion \046 Future work}{}% 37
\BOOKMARK [0][-]{section*.14}{Appendices}{}% 38
\BOOKMARK [0][-]{Appendix.1.A}{Python Script category 1: Constraint Generator}{}% 39
\BOOKMARK [0][-]{Appendix.1.B}{Python Script category 2: Constraint Generator}{}% 40
\BOOKMARK [0][-]{Appendix.1.C}{Python Script category 3: Constraint Generator}{}% 41
\BOOKMARK [0][-]{Appendix.1.D}{Python Script category 4: Constraint Generator}{}% 42
\BOOKMARK [0][-]{Appendix.1.E}{Python Script 2: Constraint Checker}{}% 43
\BOOKMARK [0][-]{Appendix.1.F}{Copy Programs}{}% 44
